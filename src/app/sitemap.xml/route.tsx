import { NextRequest, NextResponse } from "next/server";
import * as cheerio from "cheerio";

export async function GET(req: NextRequest): Promise<NextResponse> {
  const websiteUrl = "https://labxrepair.com.au/";
  const blogApi = "https://labxbackend.labxrepair.com.au/api/admin/blogs?page=1&limit=500";
  let fetchedUrls: Set<string> = new Set();

  try {
    // Fetch URLs from the website
    const response = await fetch(websiteUrl);
    const html = await response.text();
    const $ = cheerio.load(html);

    $("a").each((_, link) => {
      const url = $(link).attr("href") || "";
      if (url.trim().length > 0) {
        const fullUrl = url.startsWith("/")
          ? `${websiteUrl}${url.replace(/^\/+/, "")}`
          : url;
        if (fullUrl.startsWith(websiteUrl)) {
          fetchedUrls.add(fullUrl);
        }
      }
    });
  } catch (error) {
    console.error("Error fetching website URLs:", error);
  }

  // Manual URLs (Static Pages)
  const manualUrls = [
    "https://labxrepair.com.au/expert-motherboard-repair",
    "https://labxrepair.com.au/beginner-phone-repair-course",
    "https://labxrepair.com.au/advanced-motherboard",
    "https://labxrepair.com.au/master-motherboard-repair",
    "https://labxrepair.com.au/professional-phone-screen",
  ];

  manualUrls.forEach((url) => fetchedUrls.add(url));

  // Fetch blog posts dynamically and use the `_id` field
  try {
    const blogResponse = await fetch(blogApi);
    const { blogs } = await blogResponse.json();
    if (Array.isArray(blogs)) {
      blogs.forEach((blog: any) => {
        if (blog.pageTitle) {
          fetchedUrls.add(`${websiteUrl}blogs/${blog.pageTitle.replace(/\s+/g, '-').toLowerCase()}`);
        }
      });
    }
  } catch (error) {
    console.error("Error fetching blog URLs:", error);
  }

  // Ensure the homepage is always included
  fetchedUrls.add(websiteUrl);

  const lastMod: string = new Date().toISOString();

  // Generate XML Sitemap
  const xmlSitemap = `<?xml version="1.0" encoding="UTF-8"?>
    <urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
        ${Array.from(fetchedUrls)
          .map(
            (url) => `<url><loc>${url}</loc><lastmod>${lastMod}</lastmod></url>`
          )
          .join("\n")}
    </urlset>`;

  // Generate HTML Sitemap
  const htmlSitemap = `
    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>XML Sitemap</title>
        <style>
            body { font-family: Arial, sans-serif; margin: 40px; }
            h1 { color: #333; }
            table { width: 100%; border-collapse: collapse; margin-top: 20px; }
            th, td { border: 1px solid #ddd; padding: 10px; text-align: left; }
            th { background-color: #f4f4f4; }
            a { text-decoration: none; color: #0073e6; }
            a:hover { text-decoration: underline; }
        </style>
    </head>
    <body>
        <h1>XML Sitemap</h1>
        <p>Generated by <strong><a href="https://base2brand.com/" target="_blank">Base2Brand</a></strong>, this is an XML Sitemap, meant for search engines.</p>
        <p>This XML Sitemap contains ${fetchedUrls.size} URLs.</p>
        <table>
            <tr>
                <th>URL</th>
                <th>Last Modified</th>
            </tr>
            ${Array.from(fetchedUrls)
              .map(
                (url) => `
            <tr>
                <td><a href="${url}" target="_blank">${url}</a></td>
                <td>${lastMod}</td>
            </tr>
            `
              )
              .join("")}
        </table>
    </body>
    </html>
    `;

  // Determine response type based on request
  const acceptHeader = req.headers.get("accept");
  const isBrowser = acceptHeader?.includes("text/html") ?? false;

  return new NextResponse(isBrowser ? htmlSitemap : xmlSitemap, {
    headers: { "Content-Type": isBrowser ? "text/html" : "application/xml" },
  });
}
